# 线性代数基础与numpy学习笔记

## 前言

本篇学习笔记更关注线性代数在计算机中的运用，不重点讨论其数学性质以及定义



## 向量

计算机中，向量可以看作是有序的数字列表，例如颜色可以用RGB表示，如(128, 128, 128)、(255, 255, 255)... ...其中(128, 128, 128)就可以用一个三维向量表示，我们可以使用numpy中的一维数组表示这个向量

```python
vector = np.array([128, 128, 128])
```

其中，使用numpy.array创建新数组时，可以修改dtype参数设置数组中元素的数据类型，例如：

```python
vector1 = np.array([127, 127, 127], dtype=np.int8)
vector2 = np.array([255, 255, 255], dtype=np.uint32)
```

此外，numpy还有其他函数可以用于构建一维数组/向量

```python
>>> np.arange(10)
[0 1 2 3 4 5 6 7 8 9]
>>> np.arange(1, 10, 0.5)
[1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5 9.  9.5]
>>> np.linspace(0, 1, 10)
[1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5 9.  9.5]
```

同时，numpy库也可以实现向量之间的运算

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
c = a + b  # 向量加法（减法类似）[5 7 9]
c = np.dot(a, b)  # 向量的内积32
```



## 矩阵

类似于向量，矩阵可以看作是一个多维的有序数字列表，例如一张灰度图就可以用矩阵表示，矩阵的每个元素表示图像在对应位置的灰度值。

同样也可以使用numpy库创建矩阵

```python
# 通过列表构建矩阵
>> np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
[[1 2 3]
 [4 5 6]
 [7 8 9]]
# 特殊矩阵构建
>> np.eye(3)
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
>> np.eye(3, 4)
[[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]]
>> np.zeros((3, 4))
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
>> np.ones((3, 4))
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
```

矩阵的加减法运算同样也可以通过numpy库实现，和向量的加减法一样，矩阵的加减法即是将对应位置的元素相加或相减

```python
matrixA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
matrixB = np.array([[2, 4, 6], [8, 10, 12], [14, 16, 18]])
print(matrixA + matrixB)

[[ 3  6  9]
 [12 15 18]
 [21 24 27]]
```



## 矩阵乘法

首先学习矩阵乘法的定义：
```math
设矩阵  A=\left(a_{i j}\right)_{m \times n}  和  B=\left(b_{i j}\right)_{n \times s}  ，\\令  C=\left(c_{i j}\right)_{m \times s}  。其中  c_{i j}=\sum_{k=1}^{n} a_{i k} b_{k j}(1 \leq i \leq m, 1 \leq j \leq s)  ，\\那么矩阵 C 称为矩阵 A 与 B 的乘积，记为  \mathrm{C}=\mathrm{AB}  或  \mathrm{C}=\mathrm{A} \cdot \mathrm{B}  。
```

关于矩阵乘法更详尽的描述，可以参考本人知乎文章，其中还包含了众多有趣的几何性质！https://zhuanlan.zhihu.com/p/681878488

借助numpy库，可以很轻松的实现矩阵乘法，例如：

```python
matrixA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
matrixB = np.array([[2, 4, 6], [8, 10, 12], [14, 16, 18]])
print(np.dot(matrixA, matrixB))


[[ 60  72  84]
 [132 162 192]
 [204 252 300]]
```



## Numpy矩阵广播

广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。

如果两个数组 a 和 b 形状相同，即满足 **a.shape == b.shape**，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。

```python
a = np.array([1, 2, 3, 4]) 
b = np.array([10, 20, 30, 40]) 
c = a * b 
print(c)

[ 10  40  90 160]
```

```python
a = np.array([[0, 0, 0],
              [10, 10, 10],
              [20, 20, 20],
              [30, 30, 30]])
b = np.array([0, 1, 2])
print(a + b)

[[ 0  1  2]
 [10 11 12]
 [20 21 22]
 [30 31 32]]
```



## 行列式

简单介绍一下行列式的定义即可：
```math
设D=\left|\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1 n} \\
a_{21} & a_{22} & \cdots & a_{2 n} \\
\cdots & \cdots & \cdots & \cdots \\
a_{n 1} & a_{n 2} & \cdots & a_{n n}
\end{array}\right|\text { 是由排成 } n \text { 阶方阵形式的 } n^{2} \text { 个数 } \mathrm{a}_{\mathrm{ij}}(\mathrm{i}, \mathrm{j}=1,2, \ldots, \mathrm{n}) \text { 确定的一个数，其值为 } n!\text { 项之和 }D=\sum (-1)^{k}a_{1k_{1}}a_{2k_{2}}...a_{nk_{n}}
```

那么借助numpy库，我们可以不用记忆复杂的计算公式，同样也可以相当轻松的获得行列式的值

```python
n_array = np.array([[50, 29], [30, 44]])
print(n_array)
det = np.linalg.det(n_array)
print(int(det))

[[50 29]
 [30 44]]
1330
```

对于更大型的行列式也可以用同样的方法，但是不同于矩阵的是，行列式要求方阵的行数等于列数



## 矩阵转置

首先了解一下矩阵转置的定义

```math
设A为m\times n阶矩阵,第i行第j列的元素是a(i,j),即A=(a_{ij})_{m\times n},把m\times n矩阵A的行换成同序数的列得到一个n\times m矩阵，此矩阵叫做A的转置矩阵，记做A^{T}或A^{'}。 
```

利用numpy库可以相当直观的了解矩阵转置的定义

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
arrT = arr.T
print(arr)
print(arrT)

[[1 2 3]
 [4 5 6]]
[[1 4]
 [2 5]
 [3 6]]
```



## 矩阵的逆

矩阵求逆，即求矩阵的逆矩阵。设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩B，使得： AB=BA=E。 则我们称B是A的逆矩阵，而A则被称为可逆矩阵。其中，E为单位矩阵。

通过数学计算较为麻烦，而利用numpy库我们可以直接求得一个矩阵对应的逆矩阵，例如：

```python
arr = np.array([[1, 2], [3, 4]])
arr_inverse = np.linalg.inv(arr)
print(arr_inverse)

[[-2.   1. ]
 [ 1.5 -0.5]]
```

逆矩阵在人工智能领域具有广泛的应用价值，它不仅为求解线性方程组提供了直接的方法，还在优化算法、数据降维与特征提取、机器学习模型参数求解以及广义逆矩阵的应用等方面发挥着重要作用，此处不作详细描述。